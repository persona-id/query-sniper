package sniper

import (
	"bytes"
	"context"
	"database/sql"
	"fmt"
	"log/slog"
	"strings"
	"sync"
	"text/template"
	"time"

	// Import the mysql driver functionality, but we don't use it directly.
	_ "github.com/go-sql-driver/mysql"

	"github.com/persona-id/query-sniper/internal/configuration"
)

type QuerySniper struct {
	Connection *sql.DB
	Name       string
	Schema     string
	LRQQuery   string
	QueryLimit time.Duration
	Interval   time.Duration
}

type MysqlProcess struct {
	Command string         `db:"COMMAND"`
	DB      sql.NullString `db:"DB"`
	State   sql.NullString `db:"STATE"`
	Info    sql.NullString `db:"INFO"`
	ID      int            `db:"ID"`
	Time    int            `db:"TIME"`
}

// Sniper constructor
//
// Parameters:
//   - name: name of the sniper, the value is the databases key from the config by default.
//   - *configuration.Config: the Viper config struct with all of the application configuration
//     including database specific values.
//
// Returns:
//   - QuerySniper: the new sniper with the correct configuration, or a blank struct on error.
//   - error: any errors that occur, or nil.
func New(name string, settings *configuration.Config) (QuerySniper, error) {
	// fetch all database specific configs via key name
	dbConfig := settings.Databases[name]
	dsn := fmt.Sprintf("%s:%s@tcp(%s)/", dbConfig.Username, dbConfig.Password, dbConfig.Address)

	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return QuerySniper{}, fmt.Errorf("error opening database: %w", err)
	}

	sniper := QuerySniper{
		Name:       name,
		Connection: db,
		QueryLimit: dbConfig.LongQueryLimit,
		Interval:   dbConfig.Interval,
		Schema:     dbConfig.Schema,
		LRQQuery:   "",
	}

	query, err := sniper.generateHunterQuery()
	if err != nil {
		return QuerySniper{}, fmt.Errorf("error generating hunter query: %w", err)
	}

	sniper.LRQQuery = query

	slog.Info("Created new sniper",
		slog.String("name", sniper.Name),
		slog.String("address", dbConfig.Address),
		slog.String("schema", sniper.Schema),
		slog.String("username", dbConfig.Username),
		slog.Duration("query_limit", sniper.QueryLimit),
		slog.Duration("interval", sniper.Interval),
		slog.String("hunt_query", sniper.LRQQuery),
	)

	return sniper, nil
}

// Process the configuration file and construct all required QuerySnipers from it.
//
// Parameters:
//   - context.Context: the background context for the sniper to use.
//   - *configuration.Config: settings struct, which is loaded from the config files by go-viper.
func Run(ctx context.Context, settings *configuration.Config) {
	var wg sync.WaitGroup

	for dbName := range settings.Databases {
		sniper, err := New(dbName, settings)
		if err != nil {
			slog.Error("Error in Run()", slog.Any("err", err))

			continue
		}

		wg.Add(1)

		go func(ctx context.Context, s *QuerySniper) {
			defer wg.Done()

			s.Loop(ctx)
		}(ctx, &sniper)
	}

	wg.Wait()
}

// Loop that runs in the background that looks for long running queries and calls the Kill() command on any it finds.
//
// Parameters:
//   - context.Context: the background context for the sniper to use in the loop.
func (sniper QuerySniper) Loop(ctx context.Context) {
	ticker := time.NewTicker(sniper.Interval)

	for {
		select {
		case <-ctx.Done():
			ticker.Stop()

			return

		case <-ticker.C:
			queries, err := sniper.GetLongRunningQueries()
			if err != nil {
				slog.Error("Error in sniper.GetLongRunningQueries()", slog.Any("err", err))
			}

			if len(queries) > 0 {
				sniper.KillProcesses(queries)
			}
		}
	}
}

// Finds all long running queries, using the query generated by generateHunterQuery().
//
// Returns:
//   - []MysqlProcess: list of long running processes, or a blank list in the event of an error.
//   - error: any errors that occur, or nil.
func (sniper QuerySniper) GetLongRunningQueries() ([]MysqlProcess, error) {
	rows, err := sniper.Connection.Query(sniper.LRQQuery) //nolint:noctx,rowserrcheck
	if err != nil {
		return []MysqlProcess{}, fmt.Errorf("error getting long running queries: %w", err)
	}
	defer rows.Close()

	var processes []MysqlProcess

	for rows.Next() {
		var process MysqlProcess

		err := rows.Scan(&process.ID, &process.DB, &process.State, &process.Command, &process.Time, &process.Info)
		if err != nil {
			return []MysqlProcess{}, fmt.Errorf("error scanning long running queries: %w", err)
		}

		processes = append(processes, process)
	}

	return processes, nil
}

// Kills all of the processes in the []MysqlProcess list parameter.
//
// Parameters:
//   - []MysqlProcess, list of slow queries that need to be killed.
//
// Returns:
//   - count of killed queries.
func (sniper QuerySniper) KillProcesses(processes []MysqlProcess) int {
	killed := 0

	for _, process := range processes {
		if process.ID <= 0 {
			continue
		}

		killQuery := fmt.Sprintf("KILL %d", process.ID)

		_, err := sniper.Connection.Exec(killQuery) //nolint:noctx
		if err != nil {
			// We log here, rather than returning err, because we don't want to stop processing all of the other queries.
			slog.Error("Error killing process ID",
				slog.Int("process_id", process.ID),
				slog.String("query", process.Info.String),
				slog.String("db", process.DB.String),
				slog.Any("err", err),
			)

			continue
		}

		slog.Info("Killed process ID",
			slog.Int("process_id", process.ID),
			slog.String("query", process.Info.String),
			slog.String("db", process.DB.String),
			slog.String("state", process.State.String),
			slog.Int("time", process.Time),
		)

		killed++
	}

	return killed
}

// Generate the query used to find long running queries; uses templating to interpolate values.
//
// Returns:
//   - string: the mysql query for the sniper to use
//   - error: any errors that occur, or nil
func (sniper QuerySniper) generateHunterQuery() (string, error) {
	tmpl := template.Must(template.New("query hunter").Parse(`
		SELECT ID, DB, STATE, COMMAND, TIME, INFO
		FROM performance_schema.processlist
		WHERE COMMAND NOT IN ('Sleep', 'Killed')
		AND INFO NOT LIKE '%processlist%'
		AND DB IS NOT NULL
		{{.TimeFilter}}
		{{.DBFilter}}
		ORDER BY TIME DESC`))

	type QueryParams struct {
		TimeFilter string
		DBFilter   string
	}

	// convert the duration into seconds for use in the query
	timeout := sniper.QueryLimit.Seconds()

	params := QueryParams{
		TimeFilter: fmt.Sprintf("AND TIME >= %d", int(timeout)),
		DBFilter:   "",
	}

	if sniper.Schema != "" {
		params.DBFilter = fmt.Sprintf("AND DB in ('%s')", sniper.Schema)
	}

	var queryBytes bytes.Buffer

	err := tmpl.Execute(&queryBytes, params)
	if err != nil {
		return "", fmt.Errorf("error executing hunter query: %w", err)
	}

	result := strings.Join(strings.Fields(queryBytes.String()), " ")

	return result, nil
}
